#ifndef ALG_OTHER_DP_H_
#define ALG_OTHER_DP_H_

#include <iostream>

using namespace std;

const int INF_NEG = -10000;

/** 《算法导论》15.1 钢条切割
*
*     @param a[] 钢条价格表，有效范围[1..n]
*     @param n 数组长度
*     @return  求切割方案，得到最大销售收益
*/
int ALG_ExtendedBottomUpCutRob(int p[], int n)
{
    int *r = new int[n + 1];        // 最大收益
    int *s = new int[n + 1];        // 切割长度

    r[0] = 0;

    for (int j = 1; j <= n; j++)
    {
        int q = INF_NEG;
        for (int i = 1; i <= j; i++)
        {
            if (q < p[i] + r[j - i])
            {
                q = p[i] + r[j - i];
                s[j] = i;
            }
            r[j] = q;
        }
    }

    int maxr = r[n];

    cout << endl << "《算法导论》15.1 钢条切割" << endl;
    while (n > 0)
    {
        cout << s[n] << " ";
        n -= s[n];
    }
    cout << endl;

    delete[] r;
    delete[] s;

    return maxr;
}

/** 《算法导论》15.2 矩阵链乘法； 王晓东 3.1 矩阵连乘
*
*     @param p[] 矩阵维数，[0,1,..,n]，Ai的维数是(Pi-1*Pi)
*     @param n 矩阵个数
*     @return  最小乘法次数
*/
int ALG_MatrixChain(int *p, int n, int **m, int **s)
{
    for (int i = 1; i <=n; i++)
    {
        m[i][i] = 0;
    }

    for (int r = 2; r <= n; r++)
    {
        for (int i = 1; i <= n - r + 1; i++)
        {
            int j = i + r - 1;
            m[i][j] = m[i + 1][j] + p[i - 1] * p[i] * p[j];
            s[i][j] = i;
            for (int k = i + 1; k < j; k++)
            {
                int t = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j];
                if (t < m[i][j])
                {
                    m[i][j] = t;
                    s[i][j] = k;
                }
            }
        }
    }

    return m[1][n];
}

void ALG_MatrixTraceback(int i, int j, int **s)
{
    if (i == j)
    {
        cout << "A" << i;
    }
    else
    {
        cout << "(";
        ALG_MatrixTraceback(i, s[i][j], s);
        ALG_MatrixTraceback(s[i][j] + 1, j, s);
        cout << ")";
    }
}

#endif